# javascript 基础

- TCP/IP：传输控制协议 和 英特网互连协议 是定义数据如何传输的通信协议。
- DNS：域名系统服务器。浏览器获取网页之前将会查看域名系统，浏览器需要找到存放你想要的网页的服务器。然后发送HTTP请求到正确的地方。
- HTTP：超文本传输协议是一个定义客户端和服务器之间交流的协议。

## 容易忽视的小细节

- var (variable => 变量) 声明局部变量和全局变量，有变量提升特性，会先提升到头部声明变量，等运行到所在行时再进行赋值。
- const (constant => 常量) 声明一个只读常量，块级作用域。只是针对存取层级的限制(access limitations)，并不是不可改变性(immutability)。指的是如果你声明的常量是一个对象、函数（也是对象）、或数组类型，像这种参照类型的值，里面的值是可以再作改变的。改变值或指针的时候 const 会报错，减少犯错。
- let 声明一个块作用域的局部变量，和 const 的区分在于是否为可改变的(lexEnvRec.CreateMutableBinding)或不可改变的(lexEnvRec.CreateImmutableBinding)两种情况。
- 函数声明会被提升到顶部。函数表达式会提升声明的变量，然后再赋值匿名函数，如果在函数表达式之前调用会报错（* is not a function）。

- for...in 遍历数组时，如果数组有可枚举的属性，那么属性也会出现在被遍历的清单中。es6 新特性 for...of 却不会遍历数组可枚举的属性。
- 函数的 this 一般指向函数的对象，如果没有对象的话会指向顶层对象-window。箭头函数的 this 则指向上层的 this值，能捕捉闭包上下文的 this值。

- 0b11 二进制，0o11 八进制，0x11 十六进制。
- 1e3 = 1000, 1e6 = 1000000, 0.1e10 = 10。

- arguments 是函数体中一个内部对象，包括了所有被传入的参数。即使函数只定义了一个参数，仍能获取到所有的回调函数传入的参数。arguments.callee 指向当前正在执行的函数，严格模式下会报错。

- arguments 对象提供一个 length 属性，但是不实现 forEach() 方法。

- const regex = /ab+c/ 字面量正则表达式在保持不变时，可获得更好的性能。let regex = RegExp('ab+c') 构造函数正则表达式适合在表达式模式将会改变，或者你不知道的模式，如用户输入。

- Object 的键均为 Strings 类型，而 Map 里键可以是任意类型。WeakMap 对象也是键值对的集合，它的键必须是对象类型，且不可枚举，当对象被回收后，WeakMap 自动移除对应的键值对，及时释放内存。WeakSet 对象是一组对象的集合，不重复不可枚举。

- Set 相对于 Array 来说的优势有：（允许根据值删除元素，而数组中必须使用基于下标的 splice 方法）、（数组的 indexOf 方法无法找到 NaN 值）、（Set 对象存储不重复的值）。

- Object 是一种引用类型，两个独立声明的对象永远也不会相等，即使属性相同。只有在比较一个对象和这个对象的引用时，都会返回为 true。

- 可迭代对象中一定带有 Symbol.iterator 键的属性。String, Array, TypeArray, Map 和 Set 都内置可迭代对象，它们的原型对象都有一个 Symbol.iterator 方法。

- 不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。js 是通过引用次数来判断是否需要释放这块内存。

- 闭包，每次函数被执行的时候，就会创建一个新的，特定的作用域对象，不能直接访问该作用域对象，也没有遍历当前作用域对象里面属性的方法。

- 如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。

- 严格模式下禁止使用 with 语句，因为 with 语句无法在时就确定，属性到底归属哪个对象。

- 严格模式下禁止 this 关键字指向全局对象。禁止在函数内部遍历调用栈。禁止删除变量，只有 configurable 设置为 true 的对象才能删除。不允许对 arguments 赋值，arguments 不再追踪参数的变化，禁止使用 arguments.callee。函数必须声明在顶层，不允许在非函数的代码块内声明函数。

- null、undefined、0、""、NaN、false，等六个为假值.

- in 运算符用来判断指定的属性是否在指定的对象或原型链中。可以用来判断数组的索引号是否存在、内置对象、自定义对象。

## babel 转码

- Babel 默认是不会对 Iterator、Generator、Promise、Map、Set 等全局对象，以及一些全局对象的方法（Object.assign）转码，如果需要就必须安装引入 babel-polyfill。


## Object

- Object 构造函数为给定值创建一个对象包装器，如果给定值是 null 或 undefined，将会创建并返回一个新对象，否则，将返回一个与给定值对应类型的对象。当以非构造函数形式调用时，Object 等同于 new Object()。
